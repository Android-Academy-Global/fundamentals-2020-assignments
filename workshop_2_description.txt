Открываем класс Workshop2LocationsDbHelper.

TODO 01:
Здесь необходимо выполить SQL-запрос(ы) для создания базы данных.
Строка запроса уже написана и называется SQL_CREATE_ENTRIES.
Для то чтобы ее исполнить нужно вызвать у объекта db метод execSQL() и передать SQL_CREATE_ENTRIES как параметр.

TODO 02:
Здесь необходимо выполить SQL-запрос(ы), которые будут исполнять в случае обновления базы данных.
В случае вокшопа данный код выполняться не будет, но чтобы понять принцип мы сделаем следующее:
удалим все данные и пересоздадим базу данных.
Строка запроса для очистки всех данных уже написана и называется SQL_DELETE_ENTRIES.
Для то чтобы ее исполнить нужно вызвать у объекта db метод execSQL() и передать SQL_DELETE_ENTRIES как параметр.
После того как мы очистили все данные нам необходимо привести базу данных к начальному состоянию.
для этого нам по сути нужно выполнить тот же запрос, что мы уже выполняли в методе onCreate(TODO 01),
но тк запросов может быть больше, для того чтобы избежать дублирования кода и абстрагировать и инкапсулировать логику создан ия базы мы просто вызовем метод onCreate().

Открываем класс Workshop2LocationRepository.

TODO 03:
Здесь необходимо создать обьект Workshop2LocationsDbHelper.
Для этого замените TODO() вызовом конструктора Workshop2LocationsDbHelper.

TODO 04:
Здесь необходимо создать обьект SQLiteDatabase которы мы будем в дальнейшем использовать для чтения данныз из базы.
Для этого замените TODO() внутри блока lazy{} вызовом dbHelper.readableDatabase.
***
    Имейте ввиду, что dbHelper.readableDatabase тяжелая операция и может занять много времени, поэтому ее необходимо вызывать на отдельном потоке.
    В данном случае readableDatabase будет использоваться только на диспатчере IO, поэтому блок lazy{} тоже будет вызван на диспатчере IO.

TODO 05:
Здесь необходимо создать обьект SQLiteDatabase которы мы будем в дальнейшем использовать для записи данныз в базу.
Для этого замените TODO() внутри блока lazy{} вызовом dbHelper.writableDatabase.
***
    Имейте ввиду, что dbHelper.writableDatabase тяжелая операция и может занять много времени, поэтому ее необходимо вызывать на отдельном потоке.
    В данном случае writableDatabase будет использоваться только на диспатчере IO, поэтому блок lazy{} тоже будет вызван на диспатчере IO.

TODO 06:
Здесь необходимо перечислить все столбцы, которые нужно достать из базы для создания объектов Location.
Первый столбец(для id) уже добавлен.
Остальные находятся в LocationsContract.LocationEntry.

TODO 07:
Здесь необходимо втавить(заменить TODO()) первым параметром функции readableDatabase.query() название таблицы для запроса.
Название таблицы: LocationsContract.LocationEntry.TABLE_NAME.

TODO 08:
Здесь необходимо достать из курсора значение longitude.
Сделайте это по аналонии с тем как достается из курсора строчкой выше latitude,
изменив название столбца на LocationsContract.LocationEntry.COLUMN_NAME_LONGITUDE.

TODO 09, 10, 11:
Раскоментируйте строчку под TODO№.
У Вас должа получиться конструкция:
try {
} finally {
}

TODO 12:
Перед блоком try{} необходимо начать транзакцию.
Для этого на объекте writableDatabase(тк мы собираемся писать данные в базу) вызовите метод beginTransaction().

TODO 13:
В конце блока try{} необходимо отметить транзакцию как успешную,
тк если мы дошли до конца блока try{} - значит все операции выше успешно выполнились и ошибки не вылетали.
Для этого на объекте writableDatabase вызовите метод setTransactionSuccessful().

TODO 14:
Внутри блока finally{} необходимо завершить транзакцию независимо от того была она успешной или вылетела ошибка.
Для этого на объекте writableDatabase вызовите метод endTransaction().

У Вас должа получиться конструкция из лекции:

writableDatabase.beginTransaction()
try {
    writableDatabase.setTransactionSuccessful()
} finally {
    writableDatabase.endTransaction()
}

Далее необходимо сформировать обьект ContentValues, который необходим SQLite на Android для вставки данных в таблицу.

TODO 15:
Здесь необходимо вставить в contentValues значение request.latitude в столбец LocationsContract.LocationEntry.COLUMN_NAME_LATITUDE.
Для этого у объекта contentValues вызывает метод put:
первый параметр которого - имя столбца(LocationsContract.LocationEntry.COLUMN_NAME_LATITUDE)
второй - значение(request.latitude).

TODO 16:
Здесь необходимо вставить в contentValues значение request.longitude по аналогии с TODO 15.

TODO 17:
Здесь необходимо втавить(заменить TODO()) последним параметром функции writableDatabase.delete() значение id элемента, который мы хотим удалить.
Но синтаксис writableDatabase.delete() что последним параметром она принимает Array<String>, поэтому вставляем уже пребразованый selectionArgs.